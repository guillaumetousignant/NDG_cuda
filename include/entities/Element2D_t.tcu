#include "helpers/constants.cuh"

template<typename Polynomial>
__device__
auto SEM::Device::Entities::Element2D_t::estimate_error(deviceFloat tolerance_min, deviceFloat tolerance_max, const deviceFloat* polynomials, const deviceFloat* weights) -> void {
    const int offset_1D = N_ * (N_ + 1) /2;
    const size_t offset_2D = N_ * (N_ + 1) * (2 * N_ + 1) /6;
    const int n_points_least_squares = std::min(N_ + 1, SEM::Device::Constants::n_points_least_squares_max); // Number of points to use for thew least squares reduction, but don't go above N.

    refine_ = false;
    coarsen_ = true;

    // Pressure
    for (int node_index = 0; node_index < n_points_least_squares; ++node_index) {
        spectrum_[node_index] = deviceFloat{0};
        const int p = N_ + node_index + 1 - n_points_least_squares;

        // x direction
        for (int i = 0; i <= p; ++i) {
            deviceFloat local_spectrum{0};

            for (int k = 0; k <= N_; ++k) {
                const deviceFloat L_N_x = polynomials[offset_2D + i * (N_ + 1) + k];

                for (int l = 0; l <= N_; ++l) {
                    const deviceFloat L_N_y = polynomials[offset_2D + p * (N_ + 1) + l];

                    local_spectrum += (2 * i + 1) * (2 * p + 1) * deviceFloat{0.25} *
                                      p_[k * (N_ + 1) + l] *
                                      L_N_x * L_N_y * 
                                      weights[offset_1D + k] * weights[offset_1D + l];
                }

            }
            spectrum_[node_index] += std::abs(local_spectrum);
        }

        // y direction
        for (int j = 0; j < p; ++j) { // No need to include the last point here
            deviceFloat local_spectrum{0};

            for (int k = 0; k <= N_; ++k) {
                const deviceFloat L_N_x = polynomials[offset_2D + p * (N_ + 1) + k];

                for (int l = 0; l <= N_; ++l) {
                    const deviceFloat L_N_y = polynomials[offset_2D + j * (N_ + 1) + l];

                    local_spectrum += (2 * j + 1) * (2 * p + 1) * deviceFloat{0.25} *
                                      p_[k * (N_ + 1) + l] *
                                      L_N_x * L_N_y * 
                                      weights[offset_1D + k] * weights[offset_1D + l];
                }
            }
            spectrum_[node_index] += std::abs(local_spectrum);
        }
    }

    const auto [C_p, sigma_p] = exponential_decay(n_points_least_squares);
    p_sigma_ = sigma_p;

    // Sum of error
    p_error_ = std::sqrt(spectrum_[n_points_least_squares - 1] * spectrum_[n_points_least_squares - 1] // Why this part?
                         + C_p * C_p * deviceFloat{0.5} / sigma_p * std::exp(-2 * sigma_p * (N_ + 1)));

    if(p_error_ > tolerance_min) {	// need refinement
        refine_ = true;
    }
    if(p_error_ > tolerance_max) {	// need coarsening
        coarsen_ = false;
    }

    // Velocity x
    for (int node_index = 0; node_index < n_points_least_squares; ++node_index) {
        spectrum_[node_index] = deviceFloat{0};
        const int p = N_ + node_index + 1 - n_points_least_squares;

        // x direction
        for (int i = 0; i <= p; ++i) {
            deviceFloat local_spectrum{0};

            for (int k = 0; k <= N_; ++k) {
                const deviceFloat L_N_x = polynomials[offset_2D + i * (N_ + 1) + k];

                for (int l = 0; l <= N_; ++l) {
                    const deviceFloat L_N_y = polynomials[offset_2D + p * (N_ + 1) + l];

                    local_spectrum += (2 * i + 1) * (2 * p + 1) * deviceFloat{0.25} *
                                      u_[k * (N_ + 1) + l] *
                                      L_N_x * L_N_y * 
                                      weights[offset_1D + k] * weights[offset_1D + l];
                }

            }
            spectrum_[node_index] += std::abs(local_spectrum);
        }

        // y direction
        for (int j = 0; j < p; ++j) { // No need to include the last point here
            deviceFloat local_spectrum{0};

            for (int k = 0; k <= N_; ++k) {
                const deviceFloat L_N_x = polynomials[offset_2D + p * (N_ + 1) + k];

                for (int l = 0; l <= N_; ++l) {
                    const deviceFloat L_N_y = polynomials[offset_2D + j * (N_ + 1) + l];

                    local_spectrum += (2 * j + 1) * (2 * p + 1) * deviceFloat{0.25} *
                                      u_[k * (N_ + 1) + l] *
                                      L_N_x * L_N_y * 
                                      weights[offset_1D + k] * weights[offset_1D + l];
                }
            }
            spectrum_[node_index] += std::abs(local_spectrum);
        }
    }

    const auto [C_u, sigma_u] = exponential_decay(n_points_least_squares);
    u_sigma_ = sigma_u;

    // Sum of error
    u_error_ = std::sqrt(spectrum_[n_points_least_squares - 1] * spectrum_[n_points_least_squares - 1] // Why this part?
                         + C_u * C_u * deviceFloat{0.5} / sigma_u * std::exp(-2 * sigma_u * (N_ + 1)));

    if(u_error_ > tolerance_min) {	// need refinement
        refine_ = true;
    }
    if(u_error_ > tolerance_max) {	// need coarsening
        coarsen_ = false;
    }

    // Velocity y
    for (int node_index = 0; node_index < n_points_least_squares; ++node_index) {
        spectrum_[node_index] = deviceFloat{0};
        const int p = N_ + node_index + 1 - n_points_least_squares;

        // x direction
        for (int i = 0; i <= p; ++i) {
            deviceFloat local_spectrum{0};

            for (int k = 0; k <= N_; ++k) {
                const deviceFloat L_N_x = polynomials[offset_2D + i * (N_ + 1) + k];

                for (int l = 0; l <= N_; ++l) {
                    const deviceFloat L_N_y = polynomials[offset_2D + p * (N_ + 1) + l];

                    local_spectrum += (2 * i + 1) * (2 * p + 1) * deviceFloat{0.25} *
                                      v_[k * (N_ + 1) + l] *
                                      L_N_x * L_N_y * 
                                      weights[offset_1D + k] * weights[offset_1D + l];
                }

            }
            spectrum_[node_index] += std::abs(local_spectrum);
        }

        // y direction
        for (int j = 0; j < p; ++j) { // No need to include the last point here
            deviceFloat local_spectrum{0};

            for (int k = 0; k <= N_; ++k) {
                const deviceFloat L_N_x = polynomials[offset_2D + p * (N_ + 1) + k];

                for (int l = 0; l <= N_; ++l) {
                    const deviceFloat L_N_y = polynomials[offset_2D + j * (N_ + 1) + l];

                    local_spectrum += (2 * j + 1) * (2 * p + 1) * deviceFloat{0.25} *
                                      v_[k * (N_ + 1) + l] *
                                      L_N_x * L_N_y * 
                                      weights[offset_1D + k] * weights[offset_1D + l];
                }
            }
            spectrum_[node_index] += std::abs(local_spectrum);
        }
    }

    const auto [C_v, sigma_v] = exponential_decay(n_points_least_squares);
    v_sigma_ = sigma_v;

    // Sum of error
    v_error_ = std::sqrt(spectrum_[n_points_least_squares - 1] * spectrum_[n_points_least_squares - 1] // Why this part?
                         + C_v * C_v * deviceFloat{0.5} / sigma_v * std::exp(-2 * sigma_v * (N_ + 1)));

    if(v_error_ > tolerance_min) {	// need refinement
        refine_ = true;
    }
    if(v_error_ > tolerance_max) {	// need coarsening
        coarsen_ = false;
    }
}

template<typename Polynomial>
__device__
auto SEM::Device::Entities::Element2D_t::estimate_p_error(deviceFloat tolerance_min, deviceFloat tolerance_max, const deviceFloat* polynomials, const deviceFloat* weights) -> void {
    const int offset_1D = N_ * (N_ + 1) /2;
    const size_t offset_2D = N_ * (N_ + 1) * (2 * N_ + 1) /6;
    const int n_points_least_squares = std::min(N_ + 1, SEM::Device::Constants::n_points_least_squares_max); // Number of points to use for thew least squares reduction, but don't go above N.

    // Pressure
    for (int node_index = 0; node_index < n_points_least_squares; ++node_index) {
        spectrum_[node_index] = deviceFloat{0};
        const int p = N_ + node_index + 1 - n_points_least_squares;

        // x direction
        for (int i = 0; i <= p; ++i) {
            deviceFloat local_spectrum{0};

            for (int k = 0; k <= N_; ++k) {
                const deviceFloat L_N_x = polynomials[offset_2D + i * (N_ + 1) + k];

                for (int l = 0; l <= N_; ++l) {
                    const deviceFloat L_N_y = polynomials[offset_2D + p * (N_ + 1) + l]; 

                    local_spectrum += (2 * i + 1) * (2 * p + 1) * deviceFloat{0.25} *
                                      p_[k * (N_ + 1) + l] *
                                      L_N_x * L_N_y * 
                                      weights[offset_1D + k] * weights[offset_1D + l];
                }

            }
            spectrum_[node_index] += std::abs(local_spectrum);
        }

        // y direction
        for (int j = 0; j < p; ++j) { // No need to include the last point here
            deviceFloat local_spectrum{0};

            for (int k = 0; k <= N_; ++k) {
                const deviceFloat L_N_x = polynomials[offset_2D + p * (N_ + 1) + k];

                for (int l = 0; l <= N_; ++l) {
                    const deviceFloat L_N_y = polynomials[offset_2D + j * (N_ + 1) + l];

                    local_spectrum += (2 * j + 1) * (2 * p + 1) * deviceFloat{0.25} *
                                      p_[k * (N_ + 1) + l] *
                                      L_N_x * L_N_y * 
                                      weights[offset_1D + k] * weights[offset_1D + l];
                }
            }
            spectrum_[node_index] += std::abs(local_spectrum);
        }
    }

    const auto [C_p, sigma_p] = exponential_decay(n_points_least_squares);
    p_sigma_ = sigma_p;

    // Sum of error
    p_error_ = std::sqrt(spectrum_[n_points_least_squares - 1] * spectrum_[n_points_least_squares - 1] // Why this part?
                         + C_p * C_p * deviceFloat{0.5} / sigma_p * std::exp(-2 * sigma_p * (N_ + 1)));

    refine_ = p_error_ > tolerance_min; // need refinement
    coarsen_ = p_error_ < tolerance_max; // need coarsening
}