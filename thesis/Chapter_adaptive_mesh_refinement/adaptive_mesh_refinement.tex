\chapter{Adaptive Mesh Refinement} \label{chapter:adaptive_mesh_refinement} 
% Something about move semantics
% No coarsening
% Adaptivity triggers
% Mortar here

Computers constantly increase in power, thanks to incremental progress made on known processes and
new architectures such as that described in chapter~\ref{chapter:graphics_processing_units}.
However, processing power and memory is still limited and the size of problems studied has
increased in step with the available ressources. It is still necessary to carefully manage those
limited ressources in order to maximise the efficiency of simulations. Some flow regions may be more
interesting or harder to compute, benefiting from an increase in resolution. On the other hand, some
flow regions may have less happening in them or be easier to compute, and a decrease in resolution
may be acceptable.

It is possible to increase the number of elements and/or the polynomial order of an entire mesh
before solving the problem. This increases resolution in important areas of the flow, but also
increases resolution everywhere else in the domain, where the increased computation cost provides no
benefit. It is sometimes possible to predict where to refine before solving the problem, such as
around static shock waves in predictable locations. In these cases, the mesh can be refined in those
areas before computation has started. However, it is not always possible to know these areas
beforehand, or these areas may move as time advances if the problem is transient. The error may also
be higher in unforeseen areas that are not apparent.

Adaptive mesh refinement is the process of mesh resolution as the computation goes, where the effect
of that increase in resolution is most needed. To find out where to refine, the solution error must
be estimated, and a refinement method must be chosen. The error can be estimated by extrapolating
the value of the next mode, and the slope of the last few nodes can guide the choice of the
refinement method. The two refinement methods studied here are h-refinement and p-refinement,
increasing the number of elements and the polynomial order, respectively. 

This whole process must be executed in parallel and with as much as the work as possible executed on
the GPU. GPUs are more efficient at working with fixed workloads where all threads of a block
execute the same instruction. Refining the mesh moves memory around and can introduce additional
branching if the elements have different polynomial orders or non-conforming interfaces. The
adaptivity process itself is also hard to implement on GPUs, as elements must either move, change
their polynomial order or split into multiple elements in parallel. If the different threads are not
perfectly coordinated, they could do these operations on the same destination memory location,
creating race conditions.

Once the mesh has been refined, the element boundaries can become geometrically or functionally
non-conforming. To compute fluxes between the elements, we use the mortar element method. Mortar, in
the form of faces, is added between the elements, and the boundary solution is projected from the
elements to the face's own collocation points. 

When solving problems in parallel, the mesh will be split into blocks, each assigned to a process
and its GPU. As the mesh is refined, it is possible that the blocks are refined unequally. This can
lead to a load imbalance between the different GPUs. As the different GPUs need to synchronise at
each timestep, lightly-loaded GPUs will always be waiting after heavily-loaded GPUs. The computation
time will therefore be driven by the most heavily-loaded GPU, and the speedup incurred by
parallelizing the program will be reduced. To improve this side effect of mesh refinement, a dynamic
load balancing algorithm will be implemented in chapter~\ref{chapter:load_balancing}.

% mortar element method
% need for load balancing

\section{Strategies} \label{section:adaptive_mesh_refinement:adaptivity_strategies}

\section{Error Estimation} \label{section:adaptive_mesh_refinement:error_estimation}

\section{Refinement Criteria} \label{section:adaptive_mesh_refinement:refinement_criteria}

\section{Mortar Element Method} \label{section:adaptive_mesh_refinement:mortar_element_method}

\section{Implementation} \label{section:adaptive_mesh_refinement:implementation}

As detailed in chapter~\ref{chapter:graphics_processing_units}, the grid is stored on the GPU as a
flat array of elements, each element having pointers to its solution arrays, stored in GPU dynamic
memory. This ensures the elements have a fixed size regardless of their polynomial order.