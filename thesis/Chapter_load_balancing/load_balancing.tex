\chapter{Load Balancing} \label{chapter:load_balancing}
% Non-conforming boundaries
% Say it only uses number of elements, point to results for N influence on GPUs

A well made multi-block mesh can distribute the work evenly the different worker processes without
needing runtime adjustment if the topology and areas of more expensive computation stay the same
during the whole computation. This is complicated by the fact that, as seen in
Chapter~\ref{chapter:adaptive_mesh_refinement}, the mesh elements can increase their polynomial
order and split in multiple smaller elements in areas where the solution accuracy is not estimated
to be satisfactory. Unless the regions of interest happen to be evenly distributed between the
different processes, this will lead to an imbalance as some processes are left with more elements,
or higher-order elements, within their domain.

\begin{figure}[H]
	\centering
	\subfloat[Mesh before refining]
	{\includegraphics[width=0.45\textwidth]{Chapter_load_balancing/media/load_imbalance_initial} \label{fig:mesh_imbalance_initial_lb}}
	\hfill
	\subfloat[Mesh after refining]
	{\includegraphics[width=0.45\textwidth]{Chapter_load_balancing/media/load_imbalance} \label{fig:mesh_imbalance_after_refinement_lb}}
	\caption{Load imbalance: The elements have split unequally in the two worker GPUs, one having a higher computational load. (a) Before refining (b) After refining}
	\label{fig:load_imbalance_lb}
\end{figure}

The wall time of the simulation will be driven by the most highly-loaded process, as the processes
have to synchronise at each time step. The less-loaded processes will simply wait for the other to
finish computing.

In order to keep good performance as the mesh is refined, we will need to perform dynamic load
balancing. Dynamic load balancing seeks to even out the computational load between the different
processes. The algorithm needs to be fast, to be executed often and keep the mesh optimal longer
without overshadowing the solving time. The worker processes in this work use GPUs for their
computations. Because transfers between GPUs are expensive, the algorithm needs to limit transfers
both during the load balancing process and during computation afterwards. The workers are made up of
one CPU core and one entire GPU. This means that the worker's processing power is mostly generated
by the GPU, and the algorithm needs to use it as much as possible. The algorithm will need t have
as mny parts as possible running on the GPU, in parallel. Finally, the algorithm needs to use as
little additional GPU memory as possible, as these processors have limited memory, especially
compared to CPUs.

The algorithm needs to select which elements to send from one GPU to another. Many such algorithms
exist, notably graph-based algorithms~\cite{Karypis1998} and one-dimensional
algorithms~\cite{Pinar2004}, often called chains-on-chains partitioning. Chains-on-chains
partitioning will be used here for its relative speed. This will require a scheme to transform our
domain from two-dimensional space to one-dimensional space, as required by the algorithm.

Here, the repartitioning scheme uses Space-Filling Curves (SFC), more specifically the Hilbert
Curve. SFCs map multi-dimensional space to one-dimensional space. Elements can then be sent or
received from the ends of this space. In addition, these curves are fast to generate, use low
memory, and maximise locality. Elements that are close in curve space will also be close by in the
space used for computations. This limits the number of interfaces between processes.

\section{Hilbert curve} \label{section:load_balancing:hilbert_curve}
The Hilbert curve, by D. Hilbert~\cite{Hilbert1891}, is a specific kind of space-filling curve as
described by G. Peano~\cite{Peano1890}. This curve works for 2D domains with equal and power of two
resolution in x and y. Some newer research~\cite{Haverkort2011} shows how can such curves be
expanded to three dimensions, and arbitrary domains.

\begin{figure}[H]
	\centering
	\subfloat[First level]
	{\includesvg[width=0.3\textwidth]{Chapter_load_balancing/media/hilbert_curve_K2} \label{fig:hilbert_k2}}
	\hfill
	\subfloat[Second level]
	{\includesvg[width=0.3\textwidth]{Chapter_load_balancing/media/hilbert_curve_K4} \label{fig:hilbert_k4}}
	\hfill
	\subfloat[Third level]
	{\includesvg[width=0.3\textwidth]{Chapter_load_balancing/media/hilbert_curve_K8} \label{fig:hilbert_k8}}
	\caption{Hilbert curve: The first thee Hilbert curves. (a) 2x2 (b) 4x4 (c) 8x8}
	\label{fig:hilbert_curves}
\end{figure}

Figure~\ref{fig:hilbert_curves} shows the first three levels of the Hilbert curve. The curve
successfully maps our 2D domain to a 1D one along the curve. That 1D domain can then be partitioned
between the different worker GPUs. It can be seen that the elements have good locality and no jumps. 
Wherever the curve is cut, elements on the resulting segments are close together. This is the first 
desirable propriety of the curve for this program, as we aim to reduce the contact area between 
the mesh blocks dispatched to each GPU. The iterative nature of those curves is also apparent when
put side by side. Each increasing level of the curve follows the general path of the previous curve.
Iteration is one of the possible ways to generate this curve. It will be used to generate the
initial meshes used by the program, as well as to re-number elements when the mesh refines.

\subsection{Generation} \label{section:load_balancing:hilbert_curve:generation}
We choose a table-driven algorithm to generate meshes. Each element has one of four possible states
$s$: $s \in \left \{H, A, R, B \right \}$. This state determines the state and ordering of the four children
elements obtained when increasing the level of the curve. The four states and their resulting
children are shown in the following figure.

\begin{figure}[H]
	\centering
	\subfloat[H splitting: \newline $A, H, H, B$]
	{\includesvg[width=0.23\textwidth]{Chapter_load_balancing/media/hilbert_split_H} \label{fig:hilbert_split_H}}
	\hfill
	\subfloat[A splitting: \newline $H, A, A, R$]
	{\includesvg[width=0.23\textwidth]{Chapter_load_balancing/media/hilbert_split_A} \label{fig:hilbert_split_A}}
	\hfill
	\subfloat[R splitting: \newline $B, R, R, A$]
	{\includesvg[width=0.23\textwidth]{Chapter_load_balancing/media/hilbert_split_R} \label{fig:hilbert_split_R}}
	\hfill
	\subfloat[B splitting: \newline $R, B, R, H$]
	{\includesvg[width=0.23\textwidth]{Chapter_load_balancing/media/hilbert_split_B} \label{fig:hilbert_split_B}}
	\caption{The four states splitting, with their children's state and ordering.}
	\label{fig:hilbert_splits}
\end{figure}

When put together, and assigning $H$ as the first state of the mesh, the mesh can be iteratively
constructed to the required level.

\begin{figure}[H]
	\centering
	\subfloat[Level 0]
	{\includesvg[width=0.3\textwidth]{Chapter_load_balancing/media/hilbert_level_0} \label{fig:hilbert_l0}}
	\hfill
	\subfloat[Level 1]
	{\includesvg[width=0.3\textwidth]{Chapter_load_balancing/media/hilbert_level_1} \label{fig:hilbert_l1}}
	\hfill
	\subfloat[Level 2]
	{\includesvg[width=0.3\textwidth]{Chapter_load_balancing/media/hilbert_level_2} \label{fig:hilbert_l2}}
	\caption{First levels of the Hilbert curve with statuses $s$ ($s \in \left \{ H, A , B , R \right \}$).}
	\label{fig:hilbert_levels}
\end{figure}

This behaviour can be summarised in the following tables. The ordering of the children elements is
from the bottom left element, in counter-clockwise order. 

\begin{figure}[H]
	\centering
	\includesvg[width=0.3\textwidth]{Chapter_load_balancing/media/child_order}
	\caption{Children numbering: The $j$ children of an element, used to assign states and ordering.}
	\label{fig:child_order}
\end{figure}

These are implemented directly in the code, with the state defined as an enumeration from 0 to 3 and
the tables as arrays. The state indexes into the array to get the resulting ordering and states.
This gives the state $S(s, j)$ of a cell's j\textsuperscript{th} child in function of the cell's
state $s$. The same goes for the ordering $p$ of the children, $P(s, j)$.

\begin{table}[H]
	\begin{center}
		\begin{tabular}{ c | c c c c} 
			$S\left ( s, j \right )$ & $j = 0$ & $j = 1$ & $j = 2$ & $j = 3$  \\
			\hline
			$s = H$ & \textcolor{vs_red}{$A$} & \textcolor{vs_red}{$B$} & \textcolor{vs_red}{$H$} & \textcolor{vs_red}{$H$} \\ 
			$s = A$ & \textcolor{vs_blue}{$H$} & \textcolor{vs_blue}{$A$} & \textcolor{vs_blue}{$A$} & \textcolor{vs_blue}{$R$} \\
			$s = R$ & \textcolor{vs_teal}{$R$} & \textcolor{vs_teal}{$R$} & \textcolor{vs_teal}{$B$} & \textcolor{vs_teal}{$A$} \\
			$s = B$ & \textcolor{vs_plum}{$B$} & \textcolor{vs_plum}{$H$} & \textcolor{vs_plum}{$R$} & \textcolor{vs_plum}{$B$} \\
		\end{tabular}
	
		\caption{Children element state table: children state, with $s$ being the state of the parent element and $j$ being the j\textsuperscript{th} child.}
		\label{table:children_state}
	\end{center}
\end{table}

\begin{table}[H]
	\begin{center}
		\begin{tabular}{ c | c c c c} 
			$P\left ( s, j \right )$ & $j = 0$ & $j = 1$ & $j = 2$ & $j = 3$  \\
			\hline
			$s = H$ & \textcolor{vs_red}{$0$} & \textcolor{vs_red}{$3$} & \textcolor{vs_red}{$2$} & \textcolor{vs_red}{$1$} \\ 
			$s = A$ & \textcolor{vs_blue}{$0$} & \textcolor{vs_blue}{$1$} & \textcolor{vs_blue}{$2$} & \textcolor{vs_blue}{$3$} \\
			$s = R$ & \textcolor{vs_teal}{$2$} & \textcolor{vs_teal}{$1$} & \textcolor{vs_teal}{$0$} & \textcolor{vs_teal}{$3$} \\
			$s = B$ & \textcolor{vs_plum}{$2$} & \textcolor{vs_plum}{$3$} & \textcolor{vs_plum}{$0$} & \textcolor{vs_plum}{$1$} \\
		\end{tabular}
		
		\caption{Children element order table: children order, with $s$ being the state of the parent element and $j$ being the j\textsuperscript{th} child.}
		\label{table:children_ordering}
	\end{center}
\end{table}

This has the added benefit of working seamlessly in parallel, as each element can generate its
children using nothing more than its own order.

Without adaptive mesh refinement, no more work is needed. The elements wouldn't even need to store
their state, as the compact numbering of the elements is the result of the Hilbert curve. The mesh
generator included with the program works this way, creating an uniform power of two sized 2D mesh
numbered according to the Hilbert curve. The mesh generator uses the standard CGNS format. The
meshes generated this way can be used directly by the program on a single GPU, or split into
multiple blocks using the provided mesh partitioner. The mesh partitioner can split any single-block
CGNS mesh into a multi-block mesh, which can then be run using the main program on multiple GPUs.

\subsection{Refinement} \label{section:load_balancing:hilbert_curve:refinement}
The same iterative process is used to refine elements. The parent state dictates the state and
ordering of its children. Correct ordering is critical to maintaining good locality between elements
as the mesh refines and non-conforming interfaces are created.

\begin{figure}[H]
	\centering
	\subfloat[Before refining]
	{\includesvg[width=0.4\textwidth]{Chapter_load_balancing/media/mesh_1_before_adaptivity0} \label{fig:hilbert_before}}
	\hfill
	\subfloat[After refining]
	{\includesvg[width=0.4\textwidth]{Chapter_load_balancing/media/mesh_1_after_adaptivity0} \label{fig:hilbert_after}}
	\caption{Mesh refinement: One element refining. (a) Before splitting (b) After splitting}
	\label{fig:hilbert_refining}
\end{figure}

This process assumes knowledge of each element's status. However, this software is made to accept
standard CGNS meshes as an input. This format does not provide this information. Furthermore, this
program can accept any 2D unstructured mesh using the format, which may not be numbered according to
a Hilbert curve. 

It is therefore necessary to deduct the status of elements when reading a mesh file.
Figure~\ref{fig:hilbert_l2} gives a hint on a possible way to do this. Following the curve, each
combination of entrance side and exit side corresponds to a single state. For example, the curve
entering from the left of the element and exiting through the top always has the state $A$. This is
confirmed by examining other levels of the Hilbert curve. The same can be deduced for the first and
last elements, using only the exiting and entering side, respectively. Using this information, we
can create a 2D matrix of state in function of entering and exiting side for elements, and 1D
matrices for the first and last elements.

\begin{table}[H]
	\begin{center}
		\begin{tabular}{ c | c c c c} 
			& \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_0} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_1} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_2} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_3} \end{tabular} \\
			\hline
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_0} \end{tabular} & \begin{tabular}{c}     \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} \\ 
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_1} \end{tabular} & \begin{tabular}{c} $B$ \end{tabular} & \begin{tabular}{c}     \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} \\
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_2} \end{tabular} & \begin{tabular}{c} $B$ \end{tabular} & \begin{tabular}{c} $B$ \end{tabular} & \begin{tabular}{c}     \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} \\
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_3} \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} & \begin{tabular}{c}     \end{tabular} \\
		\end{tabular}
	
		\caption{Element state deduction table: Element state in function of curve entrance and exit side.}
		\label{table:guess_table_incomplete}
	\end{center}
\end{table}

\begin{table}[H]
	\begin{center}
		\begin{tabular}{ c c c c} 
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_0} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_1} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_2} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_3} \end{tabular} \\
			\hline
			\begin{tabular}{c} $B$ \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} \\ 
		\end{tabular}
	
		\caption{First element state deduction table: Element state in function of curve exit side.}
		\label{table:guess_table_first}
	\end{center}
\end{table}

\begin{table}[H]
	\begin{center}
		\begin{tabular}{ c | c} 
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_0} \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} \\ 
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_1} \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} \\
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_2} \end{tabular} & \begin{tabular}{c} $B$ \end{tabular} \\
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_3} \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} \\
		\end{tabular}
	
		\caption{Last element state deduction table: Element state in function of curve entrance side.}
		\label{table:guess_table_last}
	\end{center}
\end{table}

A few combinations are still undefined in the matrix. They represent the cases where the curve
enters and leaves through the same side of the element. These cases should not happen with correct
Hilbert curves. However, nonconforming geometries created while refining, or meshes created without
using a Hilbert curve may generate those geometries. Examining Figure~\ref{fig:hilbert_splits}, we
observe that for each status the first and last child element occupy the same side. We match that
side with the incoming and exiting side of the undefined cases.

\begin{figure}[H]
	\centering
	\subfloat[Bottom: $H$]
	{\includesvg[width=0.23\textwidth]{Chapter_load_balancing/media/inout_0} \label{fig:hilbert_missing_0}}
	\hfill
	\subfloat[Right: $B$]
	{\includesvg[width=0.23\textwidth]{Chapter_load_balancing/media/inout_1} \label{fig:hilbert_missing_1}}
	\hfill
	\subfloat[Top: $R$]
	{\includesvg[width=0.23\textwidth]{Chapter_load_balancing/media/inout_2} \label{fig:hilbert_missing_2}}
	\hfill
	\subfloat[Left: $A$]
	{\includesvg[width=0.23\textwidth]{Chapter_load_balancing/media/inout_3} \label{fig:hilbert_missing_3}}
	\caption{The four missing combinations: Each corresponds to a single state.}
	\label{fig:hilbert_missing_splits}
\end{figure}

We can then obtain the full matrix.

% This is madness. The easiest to vertically and horizontally center that doesn't use many packages
% or paragraphs of syntax is to enclose each cell in a tabular block. Then people wonder why I don't
% like Latex.
\begin{table}[H]
	\begin{center}
		\begin{tabular}{ c | c c c c} 
			& \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_0} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_1} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_2} \end{tabular} & \begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/out_3} \end{tabular} \\
			\hline
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_0} \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} \\ 
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_1} \end{tabular} & \begin{tabular}{c} $B$ \end{tabular} & \begin{tabular}{c} $B$ \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} \\
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_2} \end{tabular} & \begin{tabular}{c} $B$ \end{tabular} & \begin{tabular}{c} $B$ \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} & \begin{tabular}{c} $R$ \end{tabular} \\
			\begin{tabular}{c} \includesvg[width=0.1\textwidth]{Chapter_load_balancing/media/in_3} \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} & \begin{tabular}{c} $H$ \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} & \begin{tabular}{c} $A$ \end{tabular} \\
		\end{tabular}
	
		\caption{Element state deduction table: Element state in function of curve entrance and exit side.}
		\label{table:guess_table}
	\end{center}
\end{table}

Until now, we assumed the elements were axis-aligned, and numbered such that their first edge is at
the bottom. This is important, as the elements number their children from their bottom left,
counter-clockwise. If an element's first edge is not at the bottom, the wrong numbering will be
given to refining elements. Since elements can be oriented in any direction in meshes, this
situation is expected to happen. The following examples use elements numbered such that their first
side is not at the bottom, but at the right.

\begin{figure}[H]
	\centering
	\subfloat[Before refining]
	{\includesvg[width=0.4\textwidth]{Chapter_load_balancing/media/hilbert_level_1_r} \label{fig:hilbert_l1_r}}
	\hfill
	\subfloat[After refining]
	{\includesvg[width=0.4\textwidth]{Chapter_load_balancing/media/hilbert_level_2_r} \label{fig:hilbert_l2_r}}
	\caption{Refinement with rotated elements: The numbering is wrong. (a) Initial mesh (b) Refined mesh}
	\label{fig:hilbert_rotated}
\end{figure}

One might be tempted to deduct the element status in the local element referential instead. The
incoming and outgoing side will be the number of the edges the curve go through. 

\begin{figure}[H]
	\centering
	\subfloat[Before refining]
	{\includesvg[width=0.4\textwidth]{Chapter_load_balancing/media/hilbert_level_1_l} \label{fig:hilbert_l1_l}}
	\hfill
	\subfloat[After refining]
	{\includesvg[width=0.4\textwidth]{Chapter_load_balancing/media/hilbert_level_2_l} \label{fig:hilbert_l2_l}}
	\caption{Refinement with rotated elements using local referential: This is not the next level curve. (a) Initial mesh (b) Refined mesh}
	\label{fig:hilbert_local}
\end{figure}

Both methods give wrong results when the elements are rotated compared to the first edge at the
bottom case. The solution is to compute the entering and exiting side in global coordinates,
depending on the direction the curve goes in x and y. When splitting, the elements use their
rotation as an offset when numbering their children elements. The rotation of the elements is
defined as the number of quarter turns the element is rotated compared to the normal case, with the
first edge at the bottom.

\begin{figure}[H]
	\centering
	\subfloat[Before refining]
	{\includesvg[width=0.4\textwidth]{Chapter_load_balancing/media/hilbert_level_1_r} \label{fig:hilbert_l1_c}}
	\hfill
	\subfloat[After refining]
	{\includesvg[width=0.4\textwidth]{Chapter_load_balancing/media/hilbert_level_2} \label{fig:hilbert_l2_c}}
	\caption{Refinement with rotation offset: The next level curve is correct. (a) Initial mesh (b) Refined mesh}
	\label{fig:hilbert_correct}
\end{figure}

With this out of the way, it is possible to store the rotation once when the mesh is read, store it
as a member of the element class, and use it whenever the element splits to get the correct
ordering. The different elements split independently in parallel, and the Hilbert curve keeps the
ordering coherent. An element gets the new indices of its children by knowing how many elements
split before it on the curve to give a starting indice, then using the table to order the individual
children.

\begin{figure}[H]
	\centering
	\includesvg[width=0.95\textwidth]{Chapter_load_balancing/media/mesh_1_after2}
	\caption{Mesh refining: The elements follow mixed levels of the Hilbert curve, without jumps or discontinuities.}
	\label{fig:mesh_1_after2}
\end{figure}

\section{Workload leveling} \label{section:load_balancing:workload_leveling}
Now that the problem can be partitioned in one dimension, we can begin redistributing elements to
level out the workload between the different worker GPUs. We use \textit{chains-on-chains
partitioning} (CCP), where a linear list of $N$ tasks have associated weights $w$. This list of
tasks is then split $P$ parts, equal to the number of workers. 

\section{Reconstruction} \label{section:load_balancing:reconstruction}
% Having no state
% What is sent

\section{Implementation} \label{section:load_balancing:implementation}
\subsection{Element exchange} \label{section:load_balancing:implementation:element_exchange}
% and MPI datatype
% ghost elements numbering