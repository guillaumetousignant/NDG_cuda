\thispagestyle{plain} % stop the headers being added in

\begin{center}
	\vspace*{0.5cm} % vertical gap. *" makes sure Latex does not ignore the command. 
	\phantomsection\addcontentsline{toc}{chapter}{Abstract}
	{ \Large
		\textbf{A Graphics Processing Unit Based \\ 
			Discontinuous Galerkin Wave Equation Solver \\
			with hp-Adaptivity and Load Balancing \\
		}
	}
	\vspace{0.4cm}
	\large

	by \\
	\vspace{0.4cm}
	\textbf{Guillaume Tousignant}
	
	\vspace{0.9cm}
	\textbf{Abstract}
\end{center}

In order to simulate complex fluid flows with precision, high-order methods can be used to obtain
high resolution results. However, these methods are computationally expensive, and care should be
taken to optimise their execution time. \textit{\Acrfullpl{acr:GPU}} are a relatively new
architecture in the domain of scientific computing, leveraging massive parallelism at the expense of
reduced flexibility. To achieve the resolution of high-order methods with the throughput of
\acrshortpl{acr:GPU}, we present in this thesis a \acrshort{acr:GPU} implementation of the
\textit{\acrfull{acr:DG-SEM}} coupled with parallel \textit{\acrfull{acr:AMR}} to solve the
two-dimensional wave equation. 

The \textit{\acrlong{acr:DG-SEM}} splits the domain into elements, within which the solution is
represented as a weighted series of orthogonal polynomials, the \textit{Legendre polynomials} in
this case. To insure no resources are wasted, \textit{\acrlong{acr:AMR}} aims to increase the
resolution in regions of interest, via two mechanisms: \textit{h-refinement}, where elements are
split into multiple smaller ones, and \textit{p-refinement}, where the polynomial order within an
element is increased. In order to retain the fast convergence high-order methods are known for, the
\textit{mortar element method} is used to resolve the fluxes between geometrically or functionally
non-conforming elements.

Since mesh refinement can increase resolution anywhere in the domain, it is possible that some nodes
end up with more work to perform than others. Since the nodes need to synchronise multiple times
during the calculation, the computation time will be determined by the most heavily loaded node. To
remedy this imbalance, a \textit{\acrfull{acr:SFC}} based repartitioning algorithm is used to even
out the computational load and to keep a node's elements together, limiting the number of interfaces
between nodes, as these transfers are particularly costly when the data also has to be  transferred
from and to the \acrshortpl{acr:GPU} in addition to between the nodes.

% Add some results

\textbf{Keywords}: \Acrlongpl{acr:SEM}, discontinuous Galerkin, \acrlongpl{acr:GPU}, \acrlong{acr:AMR}, \acrlongpl{acr:SFC}, Hilbert curve, dynamic load balancing, \acrlong{acr:HPC}.
